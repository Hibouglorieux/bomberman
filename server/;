package main

import (
    "fmt"
    "log"
    "net/http"
	"github.com/gorilla/websocket"
)

const ID_REQ = 'i'

var all_id = make(websocket.Conn, 0)

var upgrader = websocket.Upgrader{
    ReadBufferSize:  1024,
    WriteBufferSize: 1024,
}

func reader(conn *websocket.Conn) {
    for {
    // read in a message
        messageType, p, err := conn.ReadMessage()
        if err != nil {
            log.Println(err)
            return
        }
    // print out that message for clarity
        fmt.Println(string(p))

		if (string(p)[0] == IQ_REQ)
		{

		}

        if err := conn.WriteMessage(messageType, p); err != nil {
            log.Println(err)
            return
        }

    }
}

//func wsEndpoint(w http.ResponseWriter, r *http.Request) {
//    // remove the previous fmt statement
//    // fmt.Fprintf(w, "Hello World")
//    upgrader.CheckOrigin = func(r *http.Request) bool { return true }
//	    ws, err := upgrader.Upgrade(w, r, nil)
//    if err != nil {
//        log.Println(err)
//    }
//
//    log.Println("Client Connected")
//    err = ws.WriteMessage(1, []byte("Hi Client!"))
//    if err != nil {
//        log.Println(err)
//    }
//
//	reader(ws)
//}

func	new_func(ws *websocket.Conn) {
    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
      return
    }
    for {
      messageType, p, err := conn.ReadMessage()
      if err != nil {
        return
      }

      print_binary(p) // simple print of the message

      err = conn.WriteMessage(messageType, p);
      if err != nil {
        return
      }
    }
}

func setupRoutes() {
    http.Handle("/ws", websocket.Handler(new_func))
	http.Handle("/", http.FileServer(http.Dir("..")))
}

func main() {
    fmt.Println("Hello World")
    setupRoutes()
    log.Fatal(http.ListenAndServe(":11337", nil))
}
